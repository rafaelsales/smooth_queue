Bundler.require(:runtime_dependencies)
require 'redis'
require 'redis-namespace'
require 'connection_pool'
require_relative 'smooth_queue/config'
require_relative 'smooth_queue/util'
require_relative 'smooth_queue/redix'
require_relative 'smooth_queue/retry'

module SmoothQueue
  extend Redix::Connection

  RETRY_QUEUE = 'retry'
  LOOP_INTERVAL = 15

  def self.configure(&_block)
    @config ||= Config.new
    yield config
  end

  def self.config
    @config
  end

  # Enqueue the message in the given queue
  #
  # @param [String] queue_name
  # @param [String,Hash] message JSON-serializable String or Hash
  def self.enqueue(queue_name, message)
    if !message.is_a?(String) && !message.is_a?(Hash)
      raise ArgumentError, "`message` must be a String or Hash but was #{message.class}"
    end
    raise ArgumentError "`queue` #{queue_name} if not configured" unless queue(queue_name)

    payload = Util.build_message_payload(queue_name, message)
    id = Util.generate_id
    with_nredis do |_redis|
      Redix.enqueue(queue_name, id, Util.to_json(payload))
      Util.handle_error { handle_next_message(queue_name) }
    end
  end

  # Remove the message from processing queue as it was successfully processed
  #
  # @param [String] message_id generated by SmoothQueue
  def self.done(id)
    with_nredis do |redis|
      payload = Util.from_json(redis.hget('messages', id))
      raise ArgumentError, "`id` doesn't match an existing message" unless payload
      queue_name = payload['queue']
      Redix.processing_done(queue_name, id)
      Util.handle_error { handle_next_message(queue_name) }
    end
  end

  # Move the message back to the waiting queue
  #
  # @param [String] message_id generated by SmoothQueue
  def self.retry(id)
    Retry.new(id).handle
  end

  # Start a thread that monitors queues to handle pending messages
  def self.loop_async!
    Thread.new do
      loop do
        Util.handle_error do
          handle_queued_messages
          Redix.pop_retries_to_enqueue
        end
        sleep LOOP_INTERVAL
      end
    end
  end

  def self.stats
    with_nredis do |redis|
      hash = { retry: redis.zcard(RETRY_QUEUE) }
      config.queues.each do |name, queue|
        hash[queue.name] = {
          waiting: redis.llen(name),
          processing: redis.llen(queue.processing_queue_name),
        }
      end
      hash
    end
  end

  # Take a next message from queue and move to processing queue if the concurrency is not maxed out
  #
  # @param [String] queue_name
  def self.handle_next_message(queue_name)
    id, json_payload = Redix.pick_message(queue_name)
    return unless json_payload
    payload = Util.from_json(json_payload)
    message = payload.delete('message')
    queue(queue_name).handle(id, message, payload)
  end
  private_class_method :handle_next_message

  # Get queue details by name
  #
  # @param [String,Symbol] name
  def self.queue(name)
    config.queues[name.to_s]
  end
  private_class_method :handle_next_message

  # Check and handle messages enqueued
  def self.handle_queued_messages
    config.queues.each do |name, queue|
      queue.max_concurrency.times do
        handle_next_message(name)
      end
    end
  end
  private_class_method :handle_next_message
end
